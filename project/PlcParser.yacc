%%

%name PlcParser

%pos int

%term VAR | FUN | REC | FN | END
  | IF | THEN | ELSE
  | MATCH | WITH
  | NOT | AND
  | UNDER | VBAR
  | HD | TL | ISE | CONS
  | PRINT
  | PLUS | MINUS | TIMES | DIV
  | EQUAL | NEQUAL | LT | LTE
  | COLON | SEMICOL | EQARROW | COMMA | ARROW 
  | LBRACK | RBRACK
  | LBRACE | RBRACE
  | LPAREN | RPAREN
  | TRUE | FALSE
  | NIL | INT | BOOL 
  | NAME of string | NAT of int
  | EOF

%nonterm PROG of expr
  | DECL of expr
  | EXPR of expr
  | ATOMICEXPR of expr
  | APPEXPR of expr
  | CONST of expr
  | COMPS of expr list
  | MATCHEXPR of (expr option * expr) list 
  | CONDEXPR of expr option
  | ARGS of (plcType * string) list
  | PARAMS of (plcType * string) list
  | TYPEDVAR of plcType * string
  | TYPE of plcType
  | ATOMICTYPE of plcType
  | TYPES of plcType list

%right SEMICOL ARROW CONS
%left ELSE AND EQUAL NEQUAL LT LTE PLUS MINUS TIMES DIV LBRACK
%nonassoc IF NOT HD TL ISE PRINT NAME

%eop EOF

%noshift EOF

%start PROG

%%

PROG : EXPR (EXPR) 
  | DECL (DECL)

DECL : VAR NAME EQUAL EXPR SEMICOL PROG (Let(NAME, EXPR, PROG))
  | FUN NAME ARGS EQUAL EXPR SEMICOL PROG (Let (NAME, makeAnon(ARGS, EXPR), PROG))
  | FUN REC NAME ARGS COLON TYPE EQUAL EXPR SEMICOL PROG (makeFun (NAME, ARGS, TYPE, EXPR, PROG))

EXPR : ATOMICEXPR (ATOMICEXPR)
  | APPEXPR (APPEXPR)
  | IF EXPR THEN EXPR ELSE EXPR (If((EXPR1, EXPR2, EXPR3)))
  | MATCH EXPR WITH MATCHEXPR ( Match (EXPR, MATCHEXPR))
  | NOT EXPR (Prim1 ("!", EXPR))
  | MINUS EXPR (Prim1 ("-", EXPR))
  | HD EXPR (Prim1 ("hd", EXPR))
  | TL EXPR (Prim1 ("tl", EXPR))
  | ISE EXPR (Prim1 ("ise", EXPR))
  | PRINT EXPR (Prim1 ("print", EXPR))
  | EXPR AND EXPR (Prim2 ("&&", EXPR1, EXPR2))
  | EXPR PLUS EXPR (Prim2 ("+", EXPR1, EXPR2))
  | EXPR MINUS EXPR (Prim2 ("-", EXPR1, EXPR2))
  | EXPR TIMES EXPR (Prim2 ("*", EXPR1, EXPR2))
  | EXPR DIV EXPR (Prim2 ("/", EXPR1, EXPR2))
  | EXPR EQUAL EXPR (Prim2 ("=", EXPR1, EXPR2))
  | EXPR NEQUAL EXPR (Prim2 ("!=", EXPR1, EXPR2))
  | EXPR LT EXPR (Prim2 ("<", EXPR1, EXPR2))
  | EXPR LTE EXPR (Prim2 ("<=", EXPR1, EXPR2))
  | EXPR CONS EXPR (Prim2 ("::", EXPR1, EXPR2))
  | EXPR SEMICOL EXPR (Prim2 (";", EXPR1, EXPR2))
  | EXPR LBRACK NAT RBRACK (Item (NAT, EXPR))

ATOMICEXPR : CONST (CONST)
  | NAME (Var(NAME))
  | LBRACE PROG RBRACE (PROG)
  | LPAREN EXPR RPAREN (EXPR)
  | LPAREN COMPS RPAREN (List COMPS)
  | FN ARGS EQARROW EXPR END (makeAnon (ARGS, EXPR))

APPEXPR : ATOMICEXPR ATOMICEXPR (Call(ATOMICEXPR1, ATOMICEXPR2))
  | APPEXPR ATOMICEXPR (Call (APPEXPR, ATOMICEXPR))

CONST : TRUE (ConB(true)) | FALSE (ConB(false))
  | NAT (ConI(NAT))
  | LPAREN RPAREN (List [])
  | LPAREN TYPE LBRACK RBRACK RPAREN (ESeq(TYPE))

COMPS : EXPR COMMA EXPR (EXPR1 :: EXPR2 :: [])
  | EXPR COMMA COMPS (EXPR :: COMPS)

MATCHEXPR : END ([])
  | VBAR CONDEXPR ARROW EXPR MATCHEXPR ((CONDEXPR, EXPR) :: MATCHEXPR)

CONDEXPR : EXPR (SOME EXPR)
  | UNDER (NONE)

ARGS : LPAREN RPAREN ([])
  | LPAREN PARAMS RPAREN (PARAMS)

PARAMS : TYPEDVAR (TYPEDVAR :: [])
  | TYPEDVAR COMMA PARAMS (TYPEDVAR :: PARAMS)

TYPEDVAR : TYPE NAME ((TYPE, NAME))

TYPE : ATOMICTYPE (ATOMICTYPE)
  | LPAREN TYPES RPAREN  (ListT TYPES)
  | LBRACK TYPE RBRACK (SeqT TYPE)
  | TYPE ARROW TYPE (FunT (TYPE1, TYPE2))

ATOMICTYPE : NIL (ListT [])
  | BOOL (BoolT)
  | INT (IntT)
  | LPAREN TYPE RPAREN (TYPE)

TYPES : TYPE COMMA TYPE (TYPE1 :: TYPE2 :: [])
  | TYPE COMMA TYPES (TYPE :: TYPES)